# -*- coding: utf-8 -*-
"""PROJECT 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XNVHl0mQUEmShG_7lkPdqB6G-WRqGpg0
"""

import numpy as np

# Constants
MAX_ITER = 10
TOL = 1e-6

# System Data: Bus types
# 1 - Slack bus, 2 - PV bus, 3 - PQ bus
bus_types = ['Slack', 'PV', 'PQ']

# Bus data: [P_specified (pu), Q_specified (pu), V_specified (pu), delta_specified (degrees)]
# For slack bus, P and Q are unknown, V and delta known.
# For PV bus, P and V known, Q and delta unknown.
# For PQ bus, P and Q known, V and delta unknown.
bus_data = np.array([
    [0.0, 0.0, 1.06, 0.0],     # Bus 1 - Slack
    [0.5, 0.0, 1.045, 0.0],    # Bus 2 - PV (Q unknown)
    [-0.6, -0.3, 1.0, 0.0]     # Bus 3 - PQ
])

# Admittance matrix Ybus (pu)
# Imaginary parts dominant, representing susceptances mostly.
Ybus = np.array([
    [10 - 30j, -5 + 15j, -5 + 15j],
    [-5 + 15j, 10 - 30j, -5 + 15j],
    [-5 + 15j, -5 + 15j, 10 - 30j]
])

# Initialization of voltages (magnitude and angle)
V = np.array([bus_data[i, 2] for i in range(len(bus_data))])
delta = np.radians([bus_data[i, 3] for i in range(len(bus_data))])  # in radians

def calc_power_injections(V, delta, Ybus):
    """Calculate P and Q injections at each bus."""
    n = len(V)
    P = np.zeros(n)
    Q = np.zeros(n)
    for i in range(n):
        for k in range(n):
            Y_mag = abs(Ybus[i, k])
            Y_ang = np.angle(Ybus[i, k])
            P[i] += V[i]*V[k]*Y_mag*np.cos(delta[i]-delta[k]-Y_ang)
            Q[i] += V[i]*V[k]*Y_mag*np.sin(delta[i]-delta[k]-Y_ang)
    Q = -Q  # Reactive power convention
    return P, Q

def jacobian(V, delta, Ybus, pv_buses, pq_buses):
    """Compute the Jacobian matrix components."""
    n = len(V)
    npv = len(pv_buses)
    npq = len(pq_buses)

    # Calculate P and Q for Jacobian
    P_calc, Q_calc = calc_power_injections(V, delta, Ybus)

    J11 = np.zeros((npv+npq, npv+npq))
    J12 = np.zeros((npv+npq, npq))
    J21 = np.zeros((npq, npv+npq))
    J22 = np.zeros((npq, npq))

    # Index maps for buses
    pv_pq = pv_buses + pq_buses

    # Fill J11 and J12
    for i in range(npv+npq):
        m = pv_pq[i]
        for j in range(npv+npq):
            n_ = pv_pq[j]
            if m == n_:
                sum_ = 0
                for k in range(n):
                    Y_mag = abs(Ybus[m, k])
                    Y_ang = np.angle(Ybus[m, k])
                    sum_ += V[k]*Y_mag*np.sin(delta[m]-delta[k]-Y_ang)
                J11[i, j] = -V[m]*sum_
            else:
                Y_mag = abs(Ybus[m, n_])
                Y_ang = np.angle(Ybus[m, n_])
                J11[i, j] = V[m]*V[n_]*Y_mag*np.sin(delta[m]-delta[n_]-Y_ang)

    for i in range(npv+npq):
        m = pv_pq[i]
        for j in range(npq):
            n_ = pq_buses[j]
            if m == n_:
                sum_ = 0
                for k in range(n):
                    Y_mag = abs(Ybus[m, k])
                    Y_ang = np.angle(Ybus[m, k])
                    sum_ += V[k]*Y_mag*np.cos(delta[m]-delta[k]-Y_ang)
                J12[i, j] = V[m]*sum_ + P_calc[m]
            else:
                Y_mag = abs(Ybus[m, n_])
                Y_ang = np.angle(Ybus[m, n_])
                J12[i, j] = V[m]*Y_mag*np.cos(delta[m]-delta[n_]-Y_ang)

    # Fill J21 and J22
    for i in range(npq):
        m = pq_buses[i]
        for j in range(npv+npq):
            n_ = pv_pq[j]
            if m == n_:
                sum_ = 0
                for k in range(n):
                    Y_mag = abs(Ybus[m, k])
                    Y_ang = np.angle(Ybus[m, k])
                    sum_ += V[k]*Y_mag*np.cos(delta[m]-delta[k]-Y_ang)
                J21[i, j] = V[m]*sum_
            else:
                Y_mag = abs(Ybus[m, n_])
                Y_ang = np.angle(Ybus[m, n_])
                J21[i, j] = -V[m]*V[n_]*Y_mag*np.cos(delta[m]-delta[n_]-Y_ang)

    for i in range(npq):
        m = pq_buses[i]
        for j in range(npq):
            n_ = pq_buses[j]
            if m == n_:
                sum_ = 0
                for k in range(n):
                    Y_mag = abs(Ybus[m, k])
                    Y_ang = np.angle(Ybus[m, k])
                    sum_ += V[k]*Y_mag*np.sin(delta[m]-delta[k]-Y_ang)
                J22[i, j] = -V[m]*sum_ - Q_calc[m]
            else:
                Y_mag = abs(Ybus[m, n_])
                Y_ang = np.angle(Ybus[m, n_])
                J22[i, j] = -V[m]*Y_mag*np.sin(delta[m]-delta[n_]-Y_ang]()*_*